{
  "version": 3,
  "sources": ["../../src/url/redirect-to-proxy.ts"],
  "sourcesContent": ["import { isLocalUrl } from './is-local-url'\nimport { isRelativePath } from './is-relative-path'\n\n/**\n * Redirects the request to a proxy server with a given URL. But not for:\n *\n * - Relative URLs\n * - URLs that seem to point to a local IP (except the proxy is on the same domain)\n * - URLs that don't look like a domain\n **/\nexport const redirectToProxy = (proxyUrl?: string, url?: string): string => {\n  try {\n    if (!shouldUseProxy(proxyUrl, url)) {\n      return url ?? ''\n    }\n\n    // Create new URL object from url\n    const newUrl = new URL(url)\n\n    // Add temporary domain for relative proxy URLs\n    //\n    // Q: Why isn't proxyUrl type guarded?\n    // A: Type guarding works for one parameter only (as of now).\n    //\n    // Q: Why do we need to add http://localhost to relative proxy URLs?\n    // A: Because the `new URL()` would otherwise fail.\n    //\n    const temporaryProxyUrl = isRelativePath(proxyUrl as string) ? `http://localhost${proxyUrl}` : (proxyUrl as string)\n\n    // Rewrite the URL with the proxy\n    newUrl.href = temporaryProxyUrl\n\n    // Add the original URL as a query parameter\n    newUrl.searchParams.append('scalar_url', url)\n\n    // Remove the temporary domain if we added it, but only from the start of the URL\n    const result = isRelativePath(proxyUrl as string)\n      ? newUrl.toString().replace(/^http:\\/\\/localhost/, '')\n      : newUrl.toString()\n\n    return result\n  } catch {\n    return url ?? ''\n  }\n}\n\n/**\n * Returns false for requests to localhost, relative URLs, if no proxy is defined \u2026\n **/\nexport const shouldUseProxy = (proxyUrl?: string, url?: string): url is string => {\n  try {\n    // \u274C We don't have a proxy URL or the URL\n    if (!proxyUrl || !url) {\n      return false\n    }\n\n    // \u274C Request to relative URLs (won't be blocked by CORS anyway)\n    if (isRelativePath(url)) {\n      return false\n    }\n\n    // \u2705 Proxy URL is on the same domain (e.g. /proxy)\n    // It's more likely (not guaranteed, though) that the proxy has access to local domains.\n    if (isRelativePath(proxyUrl)) {\n      return true\n    }\n\n    // \u2705 Proxy URL is local\n    if (isLocalUrl(proxyUrl)) {\n      return true\n    }\n\n    // \u274C Requests to localhost\n    // We won't reach them from a (likely remote) proxy.\n    if (isLocalUrl(url)) {\n      return false\n    }\n\n    // \u2705 Seems fine (e.g. remote proxy + remote URL)\n    return true\n  } catch {\n    return false\n  }\n}\n"],
  "mappings": "AAAA,SAAS,kBAAkB;AAC3B,SAAS,sBAAsB;AASxB,MAAM,kBAAkB,CAAC,UAAmB,QAAyB;AAC1E,MAAI;AACF,QAAI,CAAC,eAAe,UAAU,GAAG,GAAG;AAClC,aAAO,OAAO;AAAA,IAChB;AAGA,UAAM,SAAS,IAAI,IAAI,GAAG;AAU1B,UAAM,oBAAoB,eAAe,QAAkB,IAAI,mBAAmB,QAAQ,KAAM;AAGhG,WAAO,OAAO;AAGd,WAAO,aAAa,OAAO,cAAc,GAAG;AAG5C,UAAM,SAAS,eAAe,QAAkB,IAC5C,OAAO,SAAS,EAAE,QAAQ,uBAAuB,EAAE,IACnD,OAAO,SAAS;AAEpB,WAAO;AAAA,EACT,QAAQ;AACN,WAAO,OAAO;AAAA,EAChB;AACF;AAKO,MAAM,iBAAiB,CAAC,UAAmB,QAAgC;AAChF,MAAI;AAEF,QAAI,CAAC,YAAY,CAAC,KAAK;AACrB,aAAO;AAAA,IACT;AAGA,QAAI,eAAe,GAAG,GAAG;AACvB,aAAO;AAAA,IACT;AAIA,QAAI,eAAe,QAAQ,GAAG;AAC5B,aAAO;AAAA,IACT;AAGA,QAAI,WAAW,QAAQ,GAAG;AACxB,aAAO;AAAA,IACT;AAIA,QAAI,WAAW,GAAG,GAAG;AACnB,aAAO;AAAA,IACT;AAGA,WAAO;AAAA,EACT,QAAQ;AACN,WAAO;AAAA,EACT;AACF;",
  "names": []
}
