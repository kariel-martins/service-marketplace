{
  "version": 3,
  "sources": ["../../../src/utils/betterAjvErrors/helpers.ts"],
  "sourcesContent": ["import {\n  concatAll,\n  getChildren,\n  getErrors,\n  getSiblings,\n  isAdditionalPropertiesError,\n  isAnyOfError,\n  isEnumError,\n  isIfError,\n  isOneOfError,\n  isRequiredError,\n  isUnevaluatedPropertiesError,\n  notUndefined,\n} from './utils'\nimport {\n  AdditionalPropValidationError,\n  DefaultValidationError,\n  EnumValidationError,\n  PatternValidationError,\n  RequiredValidationError,\n  UnevaluatedPropValidationError,\n} from './validation-errors'\n\nconst JSON_POINTERS_REGEX = /\\/[\\w_-]+(\\/\\d+)?/g\n\n// Make a tree of errors from ajv errors array\nfunction makeTree(ajvErrors = []) {\n  const root = { children: {} }\n  ajvErrors.forEach((ajvError) => {\n    const instancePath = typeof ajvError.instancePath !== 'undefined' ? ajvError.instancePath : ajvError.dataPath\n\n    // `dataPath === ''` is root\n    const paths = instancePath === '' ? [''] : instancePath.match(JSON_POINTERS_REGEX)\n    if (paths) {\n      paths.reduce((obj, path, i) => {\n        obj.children[path] = obj.children[path] || { children: {}, errors: [] }\n        if (i === paths.length - 1) {\n          obj.children[path].errors.push(ajvError)\n        }\n        return obj.children[path]\n      }, root)\n    }\n  })\n  return root\n}\n\nfunction filterRedundantErrors(root, parent, key) {\n  const errors = getErrors(root)\n  const hasOneOfError = errors.some(isOneOfError)\n  const hasAnyOfError = errors.some(isAnyOfError)\n  const hasRequiredError = errors.some(isRequiredError)\n  const hasIfError = errors.some(isIfError)\n  const hasAdditionalPropertiesError = errors.some(isAdditionalPropertiesError)\n  const hasUnevaluatedPropertiesError = errors.some(isUnevaluatedPropertiesError)\n  const hasChildren = Object.keys(root.children || {}).length > 0\n\n  /**\n   * If there is an `if` error with `additionalProperties` or `unevaluatedProperties` error,\n   * filter out the `if` error as it's just noise from the if/then/else conditional.\n   */\n  if (hasIfError && (hasAdditionalPropertiesError || hasUnevaluatedPropertiesError)) {\n    root.errors = errors.filter((error) => !isIfError(error))\n  }\n\n  /**\n   * If there is a `oneOf` error with a `required` error:\n   * 1. If there are other errors at this level (like additionalProperties), keep those\n   * 2. If there are child errors, don't clear them - they're more meaningful\n   * The `required` error is likely from a failed oneOf branch (e.g., Reference requiring $ref).\n   */\n  if (hasOneOfError && hasRequiredError) {\n    if (hasAdditionalPropertiesError || hasUnevaluatedPropertiesError) {\n      // Filter out the required and oneOf errors, keep the meaningful ones at this level\n      root.errors = errors.filter((error) => !isRequiredError(error) && !isOneOfError(error))\n    } else if (hasChildren) {\n      // Clear parent errors, keep children as they're more meaningful\n      delete root.errors\n    } else {\n      // No other errors, keep oneOf as it's all we have\n      root.errors = errors.filter((error) => isOneOfError(error))\n    }\n  } else if (hasOneOfError && !hasRequiredError && hasChildren) {\n    /**\n     * If there is only a `oneOf` error (without required complications):\n     * If there are child errors, clear the oneOf error to surface the children.\n     * Children will have more specific information about why each branch failed.\n     */\n    // Clear the generic oneOf errors, let children surface\n    delete root.errors\n  } else if (hasOneOfError && !hasRequiredError && !hasChildren) {\n    /**\n     * If we have multiple oneOf errors (duplicates from different branches),\n     * keep only one to avoid noise.\n     */\n    const oneOfErrors = errors.filter(isOneOfError)\n    if (oneOfErrors.length > 1) {\n      // Keep only the first oneOf error\n      root.errors = [oneOfErrors[0]]\n    }\n  } else if (hasRequiredError && !hasOneOfError) {\n    /**\n     * If there is a `required` error (without oneOf complications),\n     * then we can just skip everything else.\n     * And, also `required` should have more priority than `anyOf`. @see #8\n     */\n    root.errors = errors.filter(isRequiredError)\n    root.children = {}\n  }\n\n  /**\n   * If there is an `anyOf` error that means we have more meaningful errors\n   * inside children. So we will just remove all errors from this level.\n   *\n   * If there are no children, then we don't delete the errors since we should\n   * have at least one error to report.\n   */\n  if (hasAnyOfError) {\n    if (Object.keys(root.children).length > 0) {\n      delete root.errors\n    }\n  }\n\n  /**\n   * If all errors are `enum` and siblings have any error then we can safely\n   * ignore the node.\n   *\n   * **CAUTION**\n   * Need explicit `root.errors` check because `[].every(fn) === true`\n   * https://en.wikipedia.org/wiki/Vacuous_truth#Vacuous_truths_in_mathematics\n   */\n  if (root.errors?.length && getErrors(root).every(isEnumError)) {\n    if (\n      getSiblings(parent)(root)\n        // Remove any reference which becomes `undefined` later\n        .filter(notUndefined)\n        .some(getErrors)\n    ) {\n      delete parent.children[key]\n    }\n  }\n\n  Object.entries(root.children).forEach(([k, child]) => filterRedundantErrors(child, root, k))\n}\n\nfunction createErrorInstances(root, options): Array<EnumValidationError> {\n  const errors = getErrors(root)\n  if (errors.length && errors.every(isEnumError)) {\n    const uniqueValues = new Set(concatAll([])(errors.map((e) => e.params.allowedValues)))\n    const allowedValues = [...uniqueValues]\n    const error = errors[0]\n    return [\n      new EnumValidationError(\n        {\n          ...error,\n          params: { allowedValues },\n        },\n        options,\n      ),\n    ]\n  }\n\n  return concatAll(\n    errors.reduce((ret, error) => {\n      switch (error.keyword) {\n        case 'additionalProperties':\n          return ret.concat(new AdditionalPropValidationError(error, options))\n        case 'pattern':\n          return ret.concat(new PatternValidationError(error, options))\n        case 'required':\n          return ret.concat(new RequiredValidationError(error, options))\n        case 'unevaluatedProperties':\n          return ret.concat(new UnevaluatedPropValidationError(error, options))\n        default:\n          return ret.concat(new DefaultValidationError(error, options))\n      }\n    }, []),\n  )(getChildren(root).map((child) => createErrorInstances(child, options)))\n}\n\nexport default function prettify(ajvErrors, options) {\n  const tree = makeTree(ajvErrors || [])\n  // @ts-expect-error TODO\n  filterRedundantErrors(tree)\n  return createErrorInstances(tree, options)\n}\n"],
  "mappings": "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",
  "names": []
}
