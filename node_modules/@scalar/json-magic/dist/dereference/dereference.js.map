{
  "version": 3,
  "sources": ["../../src/dereference/dereference.ts"],
  "sourcesContent": ["import { type Plugin, bundle } from '@/bundle'\nimport { fetchUrls } from '@/bundle/plugins/fetch-urls'\nimport { createMagicProxy } from '@/magic-proxy'\nimport type { UnknownObject } from '@/types'\n\ntype DereferenceResult =\n  | {\n      success: true\n      data: UnknownObject\n    }\n  | {\n      success: false\n      errors: string[]\n    }\n\ntype ReturnDereferenceResult<Opt extends { sync?: boolean }> = Opt['sync'] extends true\n  ? DereferenceResult\n  : Promise<DereferenceResult>\n\n/**\n * Dereferences a JSON object, resolving all $ref pointers.\n *\n * This function can operate synchronously (no remote refs, no async plugins) or asynchronously (with remote refs).\n * If `options.sync` is true, it simply wraps the input in a magic proxy and returns it.\n * Otherwise, it bundles the document, resolving all $refs (including remote ones), and returns a promise.\n *\n * @param input - JSON Schema object to dereference.\n * @param options - Optional settings. If `sync` is true, dereferencing is synchronous. If `plugins` is provided, those plugins are used for resolution instead of the default `fetchUrls()`.\n * @returns A DereferenceResult (or Promise thereof) indicating success and the dereferenced data, or errors.\n *\n * @example\n * // Synchronous dereference (no remote refs)\n * const result = dereference({ openapi: '3.0.0', info: { title: 'My API', version: '1.0.0' } }, { sync: true });\n * if (result.success) {\n *   console.log(result.data); // Magic proxy-wrapped document\n * }\n *\n * @example\n * // Asynchronous dereference (with remote refs)\n * dereference({ $ref: 'https://example.com/api.yaml' })\n *   .then(result => {\n *     if (result.success) {\n *       console.log(result.data); // Fully dereferenced document\n *     } else {\n *       console.error(result.errors);\n *     }\n *   });\n *\n * @example\n * // Asynchronous dereference (with custom loader plugin)\n * const plugin = { type: 'loader', validate: (v) => v.startsWith('workspace:'), exec: (v) => resolve(v) };\n * const result = await dereference({ $ref: 'workspace:my-schema' }, { plugins: [plugin] });\n */\nexport const dereference = <Opts extends { sync?: boolean; plugins?: Plugin[] }>(\n  input: UnknownObject,\n  options?: Opts,\n): ReturnDereferenceResult<Opts> => {\n  if (options?.sync) {\n    return {\n      success: true,\n      data: createMagicProxy(input),\n    } as ReturnDereferenceResult<Opts>\n  }\n\n  const errors: string[] = []\n  const plugins = options?.plugins || [fetchUrls()]\n\n  return bundle(input, {\n    plugins,\n    treeShake: false,\n    urlMap: true,\n    hooks: {\n      onResolveError(node) {\n        errors.push(`Failed to resolve ${node.$ref}`)\n      },\n    },\n  }).then((result) => {\n    if (errors.length > 0) {\n      return {\n        success: false,\n        errors,\n      }\n    }\n\n    return {\n      success: true,\n      data: createMagicProxy(result as UnknownObject),\n    }\n  }) as ReturnDereferenceResult<Opts>\n}\n"],
  "mappings": "AAAA,SAAsB,cAAc;AACpC,SAAS,iBAAiB;AAC1B,SAAS,wBAAwB;AAmD1B,MAAM,cAAc,CACzB,OACA,YACkC;AAClC,MAAI,SAAS,MAAM;AACjB,WAAO;AAAA,MACL,SAAS;AAAA,MACT,MAAM,iBAAiB,KAAK;AAAA,IAC9B;AAAA,EACF;AAEA,QAAM,SAAmB,CAAC;AAC1B,QAAM,UAAU,SAAS,WAAW,CAAC,UAAU,CAAC;AAEhD,SAAO,OAAO,OAAO;AAAA,IACnB;AAAA,IACA,WAAW;AAAA,IACX,QAAQ;AAAA,IACR,OAAO;AAAA,MACL,eAAe,MAAM;AACnB,eAAO,KAAK,qBAAqB,KAAK,IAAI,EAAE;AAAA,MAC9C;AAAA,IACF;AAAA,EACF,CAAC,EAAE,KAAK,CAAC,WAAW;AAClB,QAAI,OAAO,SAAS,GAAG;AACrB,aAAO;AAAA,QACL,SAAS;AAAA,QACT;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL,SAAS;AAAA,MACT,MAAM,iBAAiB,MAAuB;AAAA,IAChD;AAAA,EACF,CAAC;AACH;",
  "names": []
}
